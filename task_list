FUTURE
 * test case for concurrent log truncation
 * build a new project Filed_WALe -> WALe that manages multiple WALe files (named 0 to 2^64-1) of fixed maximum sizes (lets say (more than 32 MB ofcourse) 128 MB each), each new one starting at the next log_seq_nr of the previous number, and with file name 1 more than a previous number (and with extension .log). and WALe structs for which are managed as cutlery array. and an API which suggests the last log record of concern, so that WALe can trash old log files.
 * build a Filed_WALe_TS -> FiledWALe extended with redo and undo, and log serialization functions for TupleStore, with api similar to Page Modification functions.

 * Dirty page table management for supporting ARIES
   * after you perform an append_log_record, the append_only_buffer_lock is share-released and the user get the log_sequence_number of the new log record with global lock held (if using external lock)
   * so no one is allowed to enter and flush the log records, until you release the global lock
   * this allows you to update the dirty page table, while global lock is held, updating the page_id->recLSN map.
   * this ensures that the log is persistent only after the dirty page table is updated. and that the append of the log record is atomic with its update to the dirty page table