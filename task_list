FUTURE
 * utility function to get file_offset from log_sequence_number and master_record, rename util_master_record_io to util_master_record, return file_offset for any log from first_log_sequence_number to last_flushed_log_sequence_number (both included), else returns PARAM_INVALID or MASTER_RECORD_CORRUPTED as error
 * utility function to get file_offset to next_log_sequence_number
 * utility function to get block_id and block_offset from file_offset in block_io_ops.c
 * read_latest_vacant_log_record_using_master_record to return file_offset of the next_log_sequence_number
 * refactor for all the above function calls and use them instead
 * add functionality to int discard_unflushed_log_records(wale* wale_p, int* error)
   * copy on_disk_master_record to in_memory_master_record
   * read the last partially written block from the disk into append only buffer
   * modify start_block_id, append_offset accordingly
 * ensure that file_offset + total_log_size -> does not overflow 64 bit integer while appending the log, more precisely while you are reserving a slot for your log record
 * test case for concurrent log truncation
 * build a new project Filed_WALe -> WALe that manages multiple WALe files (named 0 to 2^64-1) of fixed maximum sizes (lets say (more than 32 MB ofcourse) 128 MB each), each new one starting at the next log_seq_nr of the previous number, and with file name 1 more than a previous number (and with extension .log). and WALe structs for which are managed as cutlery array. and an API which suggests the last log record of concern, so that WALe can trash old log files.
 * build a Filed_WALe_TS -> FiledWALe extended with redo and undo, and log serialization functions for TupleStore, with api similar to Page Modification functions.