 * log sequence number between 0 to block_size - 1 both inclusive are invalid. INVALID_LOG_SEQUENCE_NUMBER == 0

 * initialize_wale
   * block_io_ops
   * max_write_buffers
   * max_read_buffers
   * pthread_mutex_t* external
   
 * deinitialize_wale

 * returns log sequence number of the written log record
 uint64_t write_log_record(const logger_handle* handle, const void* log_record, uint32_t log_record_size);

 * returns log sequence number of the last log record that has been flushed to disk, this is the last_log_sequence_number as mentioned in the master record on the disk
 uint64_t get_flushed_log_sequence_number(const logger_handle* handle);

 * will first flush all the log records and then flush the master record only then the record is said to be flushed, it will return the flushed_log_sequence number if the call was successfull
 uint64_t flush_all_log_records(const logger_handle* handle);

 * returns the first and last log sequence number as found on the master record
 uint64_t get_first_log_sequence_number_of(const logger_handle* handle);
 uint64_t get_last_log_sequence_number_of(const logger_handle* handle);

 * below 2 queries can only be done for log records between first_log_sequence_number and last_log_sequence_number (as on the master record on the disk), inclusive
 the prev of first and next of last returns 0
 uint64_t get_next_log_sequence_number_of(const logger_handle* handle, uint64_t log_sequence_number);
 uint64_t get_prev_log_sequence_number_of(const logger_handle* handle, uint64_t log_sequence_number);

 * the above query must be made only when you know that the given log_sequence_number is valid and must be between first and last log sequence number
 void* get_log_record_at(const logger_handle* handle, uint64_t log_sequence_number); you must free the log record

 * above 3 queries use the bufferpool and if any of the data is already in the current write buffer, then it is read from there instead of the bufferpool

 * now the log sequence number = the offset of the log record in context - block_size + first_log_sequence_number
 * each log record stores the size of the current log record in the prefix and the suffix of the log record, this size also includes the 8 bytes used for the prefix and suffix
 * each log file has a master record at offset 0, and size equal to the block size storing
 uint64_t first_log_sequence_number -> the log record at block_id = 1 -> offset = block_size
 uint64_t last_log_sequence_number  -> this log recod can be found at (last_log_sequence_number - first_log_sequence_number) + block_size

 * all uintN_t values stored on the log records are little endian

